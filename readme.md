# Система промптов AI-ментора: Анализ и документация

## Обзор системы промптов

Система AI-ментора использует специализированные промпты для создания четырех различных AI-экспертов. Каждый промпт спроектирован для формирования уникального поведения и функциональности, при этом все промпты следуют единой архитектурной модели и используют общие принципы взаимодействия.

## Архитектура промптов

### Единая структурная модель

Все промпты в системе следуют одинаковой архитектурной схеме:

```
┌─────────────────────────────────────────────────────────┐
│                    ПРОМПТ СТРУКТУРА                     │
├─────────────────────────────────────────────────────────┤
│ 1. КТО ТЫ (Role Definition)                             │
│    • Основная роль и специализация                      │
│    • Контекст системы экспертов                         │
├─────────────────────────────────────────────────────────┤
│ 2. КОНТЕКСТ (Context Injection)                         │
│    • Профиль студента                                   │
│    • Образовательный контент                            │
│    • Текущее состояние                                  │
├─────────────────────────────────────────────────────────┤
│ 3. ФОРМАТ ОТВЕТОВ (Response Format)                     │
│    • JSON структура                                     │
│    • Примеры правильных ответов                         │
├─────────────────────────────────────────────────────────┤
│ 4. ФУНКЦИОНАЛЬНЫЕ БЛОКИ (Functional Blocks)             │
│    • Специфичные для роли инструкции                    │
│    • Этапы работы                                       │
│    • Принципы поведения                                 │
├─────────────────────────────────────────────────────────┤
│ 5. КОМАНДЫ И МЕТАДАННЫЕ (Commands & Metadata)           │
│    • Доступные системные команды                        │
│    • Параметры команд                                   │
│    • Правила использования метаданных                   │
├─────────────────────────────────────────────────────────┤
│ 6. ОГРАНИЧЕНИЯ (Constraints)                            │
│    • Запрещенные действия                              │
│    • Этические принципы                                │
│    • Технические ограничения                           │
└─────────────────────────────────────────────────────────┘
```

## Анализ промптов по экспертам

### 1. Промпт регистратора (Registrator Expert)

**Особенности конструкции:**
- **Минималистичный контекст**: Самый простой промпт, так как работает с новыми пользователями
- **Фокус на приветствии**: Основная задача - создать позитивное первое впечатление
- **Простая логика команд**: Всего 3 команды (register, login, switch)

**Ключевые элементы промпта:**
```
КТО ТЫ: Эксперт по приветствию и регистрации
ЗАДАЧА: Собрать информацию для регистрации/логина
КОМАНДЫ: register_student, login_student, switch_to_next_expert
```

**Промпт-инжиниринг особенности:**
- Отсутствие персонального контекста (студент еще не создан)
- Упор на системную информацию о других экспертах
- Четкие инструкции по переходу к следующему этапу

### 2. Промпт интервьюера (Interview Expert)

**Особенности конструкции:**
- **Многоэтапная структура**: Явно определенные этапы интервью (WELCOME → BACKGROUND → GOALS → PREFERENCES → PLAN_GENERATION → COMPLETE)
- **Богатый контекст**: Полный профиль студента + вся образовательная программа
- **Адаптивная логика**: Промпт учит AI адаптироваться под ответы студента

**Структура этапов в промпте:**
```
ЭТАПЫ ИНТЕРВЬЮ:
1. WELCOME - Приветствие и знакомство
2. BACKGROUND - Опыт и образование  
3. GOALS - Цели обучения и карьеры
4. PREFERENCES - Предпочтения в обучении
5. PLAN_GENERATION - Создание плана
6. COMPLETE - Завершение
```

**Промпт-инжиниринг техники:**
- **Контекстное ветвление**: Инструкции по адаптации вопросов
- **Прогрессивное раскрытие**: От общих к специфичным вопросам
- **Метаданные состояния**: Отслеживание текущего этапа через metadata

**Сложная команда update_student_background:**
```python
# Пример сложной структуры параметров
{
    "programming_experience": "...",
    "education_background": "...",
    "learning_goals": "...",
    "recommended_topics": {
        "topic_id1": "topic_name1",
        "topic_id2": "topic_name2"
    }
}
```

### 3. Промпт преподавателя (Teacher)

**Особенности конструкции:**
- **Педагогический фокус**: Промпт внедряет принципы эффективного преподавания
- **Динамический контекст**: Получает информацию о текущем изучаемом материале
- **Навигационные команды**: Специализированные команды для перемещения по контенту

**Встроенные педагогические принципы:**
```
ПРИНЦИПЫ ПРЕПОДАВАНИЯ:
1. От простого к сложному
2. Связь с уже изученным материалом  
3. Конкретные примеры из реальной жизни
4. Проверка понимания через вопросы
5. Поощрение вопросов от студента
```

**Промпт-инжиниринг особенности:**
- **Эмоциональное программирование**: Детальные инструкции по стилю общения
- **Визуализационные директивы**: "Визуализируй с помощью ------"
- **Адаптивность под стиль**: Учет предпочтений студента из профиля

### 4. Промпт тестировщика (Test Expert)

**Особенности конструкции:**
- **Объективность**: Промпт настраивает на справедливую оценку
- **Четкие критерии**: Встроенная шкала оценивания
- **Конструктивность**: Фокус на помощи, а не критике

**Встроенная система оценки:**
```
КРИТЕРИИ ОЦЕНКИ:
- 90-100% - Отличное понимание материала
- 75-89% - Хорошее понимание с небольшими пробелами  
- 60-74% - Удовлетворительное понимание, требуется повторение
- 45-59% - Слабое понимание, необходимо переизучение
- Менее 45% - Неудовлетворительно, требуется полное переизучение
```

## Универсальные промпт-паттерны

### Паттерн 1: Контекстная инъекция

Все промпты используют динамическую инъекцию контекста:

```python
# В коде сервиса
student_context = self._format_student_context(student_id)
content_context = await self._get_current_content_context(student_id)

prompt = f"""КТО ТЫ: ...
{student_context}
{content_context}
..."""
```

**Преимущества паттерна:**
- Персонализация без изменения базового промпта
- Динамическое обновление контекста
- Модульность компонентов промпта

### Паттерн 2: Структурированный вывод

Все промпты используют одинаковый паттерн для JSON-вывода:

```json
{
    "user_message": "Сообщение для пользователя",
    "metadata": {
        "actions": [
            {
                "description": "Что делаем",
                "command": "имя_команды", 
                "params": {...}
            }
        ]
    }
}
```

**Техники обеспечения структуры:**
- **Примеры в промпте**: Конкретные примеры правильного JSON
- **Повторение формата**: Многократное упоминание структуры
- **Явные запреты**: "ТОЛЬКО валидный JSON без дополнительного текста"

### Паттерн 3: Ограничения и этика

Все промпты содержат блок ЗАПРЕЩЕНО:

```
ЗАПРЕЩЕНО:
- Давать гарантии трудоустройства
- Обещать конкретные сроки или результаты  
- Критиковать без конструктивных предложений
- Включать команды в user_message - только в metadata
```

## Техники промпт-инжиниринга

### 1. Роле-ориентированное программирование

Каждый промпт создает четкую роль с:
- **Профессиональной идентичностью**: "Ты эксперт по..."
- **Контекстом работы**: Описание системы экспертов
- **Специализацией**: Уникальные задачи и функции

### 2. Многоуровневые инструкции

Промпты используют иерархию инструкций:
- **Глобальные правила**: Применяются ко всем ситуациям
- **Контекстные правила**: Зависят от ситуации
- **Специфичные команды**: Для конкретных действий

### 3. Примеры и шаблоны

```
ПРИМЕР ПРАВИЛЬНОГО ОТВЕТА:
```json
{
    "user_message": "...",
    "metadata": {...}
}
```
```

Каждый промпт содержит конкретные примеры правильного поведения.

### 4. Эмоциональное программирование

Промпты явно программируют эмоциональный стиль:

```
СТИЛЬ ОБЩЕНИЯ:
- Терпеливый и понимающий
- Поощряющий вопросы  
- Адаптирующийся под уровень студента
- Мотивирующий при трудностях
```

### 5. Метакогнитивные инструкции

Промпты учат AI размышлять о процессе:
- "Адаптируй вопросы под ответы студента"
- "Переходи к следующему этапу только после сбора достаточной информации"
- "Уточняй неясные или неполные ответы"

## Проблемы и ограничения текущих промптов

### 1. Избыточность

**Проблема**: Много повторяющейся информации между промптами
- Описание системы экспертов повторяется 4 раза
- Блок ЗАПРЕЩЕНО практически идентичен
- Инструкции по JSON-формату дублируются

**Решение**: Создание базового промпта с наследованием специфичных частей

### 2. Длина промптов

**Проблема**: Промпты очень длинные (особенно для преподавателя и интервьюера)
- Увеличивает стоимость API-вызовов
- Может снижать фокус AI на ключевых инструкциях

**Решение**: Оптимизация через вынесение статичной информации в отдельные компоненты

### 3. Жесткость структуры

**Проблема**: Строгий JSON-формат может ограничивать естественность
- AI может показаться роботизированным
- Сложно обрабатывать исключительные ситуации

### 4. Контекстные переключения

**Проблема**: Переходы между экспертами могут быть резкими
- Нет промптов для плавных переходов
- Студент может растеряться при смене стиля общения

## Рекомендации по улучшению

### 1. Модульная архитектура промптов

```python
base_prompt = """
Базовые инструкции и контекст системы...
"""

role_specific_prompt = """
Специфичные для роли инструкции...
"""

final_prompt = base_prompt + role_specific_prompt + context
```

### 2. Динамическая оптимизация

- Сокращение контекста для простых запросов
- Расширение для сложных сценариев
- Адаптивная детализация инструкций

### 3. A/B тестирование промптов

- Тестирование разных формулировок
- Измерение качества ответов
- Итеративное улучшение

### 4. Система переходов

Создание специальных промптов для переходов между экспертами:

```json
{
    "user_message": "Отлично! Теперь передаю вас нашему преподавателю...",
    "metadata": {
        "transition": true,
        "from_expert": "interview_expert",
        "to_expert": "teacher",
        "context_summary": "..."
    }
}
```

## Интеграция промптов с бэкенд-системой

### Архитектура взаимодействия

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   HTTP Client   │───▶│  EduChatService  │───▶│ EduPromptService│
└─────────────────┘    └──────────────────┘    └─────────────────┘
                                │                        │
                                ▼                        ▼
                       ┌─────────────────┐    ┌─────────────────┐
                       │   LLMClient     │    │ Context Builder │
                       └─────────────────┘    └─────────────────┘
                                │                        │
                                ▼                        ▼
                       ┌─────────────────┐    ┌─────────────────┐
                       │ JSON Response   │    │ Student/Topic   │
                       │ with Commands   │    │   Repositories  │
                       └─────────────────┘    └─────────────────┘
                                │
                                ▼
                       ┌─────────────────┐
                       │ Command Executor│
                       └─────────────────┘
```

### Система команд в промптах

Промпты программируют AI генерировать команды в JSON-метаданных:

```python
# Пример ответа AI
{
    "user_message": "Давайте перейдем к изучению Python основ!",
    "metadata": {
        "actions": [
            {
                "description": "Переключаемся на изучение темы Python",
                "command": "nav_to_topic",
                "params": {"topic_id": "1", "block_id": "1", "chapter_id": "1"}
            }
        ]
    }
}
```

### Типизированная система команд

Код использует Enum для типизации команд:

```python
class CommandType(Enum):
    SWITCH_EXPERT = "switch_expert"        # Переключение экспертов
    NAVIGATION = "navigation"              # Навигация по контенту  
    PROFILE_UPDATE = "profile_update"      # Обновление профиля
    INTERVIEW_CONTROL = "interview_control" # Управление интервью
    TEST_CONTROL = "test_control"          # Тестирование
    SYSTEM = "system"                      # Системные команды
```

### Команды по экспертам

#### Registrator Expert Commands
```python
# Промпт определяет эти команды:
- register_student: {"login": str, "password": str}
- login_student: {"login": str, "password": str}  
- switch_to_next_expert: {"next_expert": str}
```

#### Interview Expert Commands
```python
# Сложная команда обновления профиля:
- update_student_background: {
    "programming_experience": str,
    "education_background": str,
    "learning_goals": str,
    "career_goals": str,
    "timeline": str,
    "learning_style": str,
    "lesson_duration": str,
    "preferred_difficulty": str,
    "recommended_topics": Dict[int, str],
    "recommended_blocks": Dict[int, str],
    "approved_topics": Dict[int, str],
    "approved_blocks": Dict[int, str],
    "approved_chapters": Dict[int, str],
    "strong_areas": str,
    "weak_areas": str
}
```

#### Teacher Commands
```python
# Навигационные команды:
- nav_to_topic: {"topic_id": str, "block_id": str, "chapter_id": str}
- nav_to_block: {"topic_id": str, "block_id": str, "chapter_id": str}
- nav_to_chapter: {"topic_id": str, "block_id": str, "chapter_id": str}
```

#### Test Expert Commands
```python
# Команды подтверждения прогресса:
- approve_topic: {"topic_id": str}
- approve_block: {"block_id": str}
- approve_chapter: {"chapter_id": str}
```

### Контекстная инъекция

Промпты получают динамический контекст через методы сервиса:

```python
# EduPromptService методы инъекции контекста:
async def _format_student_context(self, student_id: int) -> str:
    # Получает полный профиль студента из БД
    # Форматирует в читаемый для AI текст

async def _format_all_content_metadata(self) -> str:
    # Получает всю образовательную программу
    # Создает flat и hierarchical JSON представления

async def _get_current_content_context(self, student_id: int) -> str:
    # Получает текущий изучаемый контент
    # Включает детали текущей главы
```

### Форматтер образовательных данных

Класс `EducationDataFormatter` создает две структуры данных для промптов:

```python
# Плоская структура - для обзора всего контента
{
    "topics": [...],
    "blocks": [...], 
    "chapters": [...]
}

# Иерархическая - для понимания связей
{
    "topics": [
        {
            "id": 1,
            "name": "Python",
            "blocks": [
                {
                    "id": 1, 
                    "name": "Основы",
                    "chapters": [...]
                }
            ]
        }
    ]
}
```

### API эндпоинты

Система предоставляет отдельные эндпоинты для каждого эксперта:

```python
# HTTP роуты:
POST /api/edu/message/send/interview-expert
POST /api/edu/message/send/teacher  
POST /api/edu/message/send/test-expert

# Модель запроса:
{
    "student_id": int,
    "text": str
}

# Модель ответа:
{
    "llm_response": str  # JSON с user_message + metadata
}
```

### Отсутствующие компоненты

В коде видны заготовки, но не реализованы:

```python
# Пустые файлы - требуют реализации:
- EduChatService     # Основная бизнес-логика  
- EduChatRepo        # Сохранение истории чата
- StudentRepo        # Управление профилями студентов
- Command Executor   # Исполнение команд из AI ответов
```

### Телеметрия и мониторинг

Система использует OpenTelemetry для отслеживания:

```python
# Tracing в каждом методе промпт-сервиса:
with self.tracer.start_as_current_span(
    "EduPromptService.get_teacher_prompt",
    kind=SpanKind.INTERNAL,
    attributes={"student_id": student_id}
) as span:
    # Логирование успеха/ошибок
    # Измерение производительности
```

### Middleware слои

Трехуровневая система middleware:

```python
# Порядок обработки:
1. trace_middleware01    # Создание span, извлечение trace_id
2. metrics_middleware02  # Сбор метрик производительности  
3. logger_middleware03   # Структурированное логирование
```

## Архитектурные наблюдения

### Сильные стороны реализации

1. **Четкое разделение ответственности**
   - Промпты изолированы в отдельном сервисе
   - Каждый эксперт имеет свой API эндпоинт
   - Команды типизированы через Enum

2. **Контекстная архитектура**
   - Динамическая инъекция контекста студента
   - Автоматическое форматирование образовательного контента
   - Адаптация промптов под текущее состояние

3. **Наблюдаемость**
   - Полная трассировка через OpenTelemetry
   - Структурированные логи с контекстом
   - Метрики производительности

4. **Типобезопасность**
   - Pydantic модели для API
   - Dataclass для внутренних структур
   - Enum для типизации команд

### Области для доработки

1. **Отсутствующая бизнес-логика**
   - EduChatService не реализован
   - Нет исполнителя команд
   - Отсутствуют репозитории

2. **Обработка команд**
   - Промпты генерируют команды, но нет их обработки
   - Нет валидации параметров команд
   - Отсутствует rollback при ошибках

3. **Состояние диалога**
   - Нет сохранения истории чата
   - Отсутствует контекст диалога между запросами
   - Нет механизма восстановления состояния

## Заключение

Система промптов AI-ментора демонстрирует продвинутую архитектуру, где промпты служат "программным интерфейсом" для AI:

**Инновационные аспекты:**
- Промпты как конфигурация поведения AI
- Команды в JSON метаданных для интеграции с бэкендом
- Динамическая контекстная инъекция
- Типизированная система команд

**Production-готовность:**
- Структурированные логи и трассировка
- API с правильными HTTP кодами
- Обработка ошибок с контекстом
- Middleware для мониторинга

**Требует доработки:**
- Реализация EduChatService с бизнес-логикой
- Command Executor для обработки AI команд
- Репозитории для персистентности данных
- Механизм управления состоянием диалога

Система показывает, как правильно спроектированные промпты могут служить "программными контрактами" между AI и бэкенд-системой, превращая LLM в управляемый компонент enterprise-архитектуры.